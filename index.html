<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–ö–æ–ª–µ—Å–æ —Ñ–æ—Ä—Ç—É–Ω—ã</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 0; background: #0b0f19; color: #e8eefc; display: grid; place-items: center; min-height: 100vh; }
    .card { width: min(520px, 92vw); background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 18px; padding: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; gap: 14px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .wheel-wrap { position: relative; display: grid; place-items: center; gap: 10px; margin-top: 12px; }
    canvas { background: transparent; }
    .win-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 4;
    }
    .win-bow {
      position: absolute;
      top: 4%;
      left: 4%;
      width: clamp(140px, 30vw, 190px);
      opacity: 0;
      transform: translateY(-10px) scale(0.95);
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.45));
      transition: opacity 180ms ease, transform 220ms ease;
      pointer-events: none;
    }
    .win-bow svg { width: 100%; height: auto; display: block; }
    .win-bow.is-visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .bow-string {
      transform-origin: 72% 50%;
      transition: transform 280ms ease;
    }
    .bow-body {
      transform-origin: 50% 50%;
      transition: transform 260ms ease;
    }
    .win-arrow {
      position: absolute;
      width: clamp(150px, 34vw, 210px);
      height: auto;
      opacity: 0;
      transform-origin: 18% 50%;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.45));
      pointer-events: none;
    }
    .win-arrow svg { width: 100%; height: 100%; display: block; }
    .win-arrow.is-active { opacity: 1; }
    .win-arrow.is-nocked {
      opacity: 1;
      transform: translate(var(--bow-x), var(--bow-y)) translate(-18%, -50%) rotate(var(--bow-rot));
      transition: transform 260ms ease, opacity 120ms ease;
    }
    .win-overlay.is-drawing .win-arrow.is-nocked {
      transform: translate(var(--bow-x), var(--bow-y)) translate(-18%, -50%) rotate(var(--bow-rot)) translateX(-24px);
    }
    .win-overlay.is-drawing .bow-string {
      transform: translateX(-12px);
    }
    .win-overlay.is-drawing .bow-body {
      transform: rotate(-1.4deg);
    }
    .win-arrow.is-animating {
      animation:
        arrow-flight 700ms cubic-bezier(0.2, 0.7, 0.2, 1) forwards,
        arrow-impact 220ms 700ms ease-out forwards;
    }
    @keyframes arrow-flight {
      0% {
        transform: translate(var(--start-x), var(--start-y)) translate(-18%, -50%) rotate(var(--start-rot));
      }
      70% {
        transform: translate(var(--mid-x), var(--mid-y)) translate(-18%, -50%) rotate(var(--mid-rot));
      }
      100% {
        transform: translate(var(--end-x), var(--end-y)) translate(-18%, -50%) rotate(var(--end-rot));
      }
    }
    @keyframes arrow-impact {
      0% {
        transform: translate(var(--end-x), var(--end-y)) translate(-18%, -50%) rotate(var(--end-rot));
      }
      60% {
        transform: translate(var(--end-x), var(--end-y)) translate(-18%, -50%) rotate(calc(var(--end-rot) + 3deg)) scale(1.04);
      }
      100% {
        transform: translate(var(--end-x), var(--end-y)) translate(-18%, -50%) rotate(var(--end-rot)) scale(1);
      }
    }
    .win-modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(5, 8, 18, 0.72);
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: auto;
    }
    .win-modal {
      position: absolute;
      left: 50%;
      top: 50%;
      width: min(92%, 420px);
      transform: translate(-50%, -50%) scale(0.92);
      background: linear-gradient(180deg, #ffffff 0%, #f4f7ff 100%);
      color: #0f172a;
      border-radius: 24px;
      padding: 26px 22px 22px;
      box-shadow: 0 25px 60px rgba(0,0,0,0.35);
      opacity: 0;
      transition: opacity 220ms ease, transform 240ms ease;
      pointer-events: auto;
    }
    .win-modal__title {
      font-size: 20px;
      font-weight: 800;
      margin-bottom: 10px;
      text-align: center;
    }
    .win-modal__prize {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 6px;
      text-align: center;
    }
    .win-modal__sector {
      font-size: 14px;
      color: #475569;
      text-align: center;
      margin-bottom: 18px;
    }
    .win-modal__close {
      position: absolute;
      top: 12px;
      right: 14px;
      border: 0;
      background: rgba(15, 23, 42, 0.08);
      color: #0f172a;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
    }
    .win-modal__button {
      width: 100%;
      background: #2563eb;
      padding: 14px 16px;
      font-size: 16px;
      border-radius: 14px;
      box-shadow: 0 12px 24px rgba(37,99,235,0.3);
    }
    .win-overlay.is-modal-open {
      pointer-events: auto;
    }
    .win-overlay.is-modal-open .win-modal-backdrop,
    .win-overlay.is-modal-open .win-modal {
      opacity: 1;
    }
    .win-overlay.is-modal-open .win-modal {
      transform: translate(-50%, -50%) scale(1);
    }
    button {
      appearance: none; border: 0; cursor: pointer;
      background: #3b82f6; color: white; font-weight: 700;
      padding: 12px 14px; border-radius: 12px;
      box-shadow: 0 10px 20px rgba(59,130,246,.25);
      transition: transform .05s ease;
      width: 100%;
    }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .small { opacity: .8; font-size: 13px; line-height: 1.35; }
    .result { margin-top: 10px; font-size: 16px; font-weight: 700; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .grid { display:grid; gap: 10px; }
    .inputs { display:flex; gap: 10px; flex-wrap: wrap; }
    input {
      flex: 1 1 160px;
      padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25); color: #e8eefc;
      outline: none;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="row">
      <h1>üé° –ö–æ–ª–µ—Å–æ —Ñ–æ—Ä—Ç—É–Ω—ã</h1>
      <span class="pill" id="status">–ì–æ—Ç–æ–≤–æ</span>
    </div>

    <div class="small">
      –í–≤–µ–¥–∏ –ø—Ä–∏–∑—ã —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é –∏ –∂–º–∏ ¬´–ö—Ä—É—Ç–∏—Ç—å¬ª.
    </div>

    <div class="inputs" style="margin-top: 12px;">
      <input id="itemsInput" placeholder="(–≤–≤–µ–¥–∏ –ø—Ä–∏–∑—ã —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)" />
      <input id="seedInput" placeholder="(–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) —Å–∏–¥, –Ω–∞–ø—Ä–∏–º–µ—Ä 123" />
    </div>

    <div class="wheel-wrap">
      <canvas id="wheel" width="360" height="360"></canvas>
      <div class="win-overlay" id="winOverlay" aria-hidden="true">
        <div class="win-bow" id="winBow">
          <svg viewBox="0 0 220 220" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="bowWood" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0" stop-color="#5a3519"/>
                <stop offset="0.5" stop-color="#9c5f2d"/>
                <stop offset="1" stop-color="#3f220f"/>
              </linearGradient>
              <linearGradient id="bowEdge" x1="0" x2="1" y1="0" y2="0">
                <stop offset="0" stop-color="rgba(255,255,255,0.25)"/>
                <stop offset="0.5" stop-color="rgba(255,255,255,0)"/>
                <stop offset="1" stop-color="rgba(0,0,0,0.2)"/>
              </linearGradient>
            </defs>
            <path class="bow-body" d="M70 16 C42 64 36 108 46 152 C54 186 70 206 92 210 C108 212 122 202 132 186 C146 162 150 126 144 96 C138 64 122 38 100 22 C88 14 78 14 70 16 Z" fill="url(#bowWood)" stroke="#3c220f" stroke-width="4"/>
            <path d="M74 20 C48 66 46 110 56 150 C64 182 80 198 96 202 C110 204 122 196 130 180 C142 158 144 124 138 96 C132 68 118 42 98 30 C88 24 80 22 74 20 Z" fill="none" stroke="url(#bowEdge)" stroke-width="6" opacity="0.6"/>
            <rect x="92" y="94" width="28" height="46" rx="12" fill="#1f2937" opacity="0.85"/>
            <rect x="96" y="100" width="20" height="34" rx="8" fill="#374151"/>
            <path class="bow-string" d="M78 28 Q132 110 98 196" stroke="#e2e8f0" stroke-width="2.4" fill="none"/>
          </svg>
        </div>
        <div class="win-arrow" id="winArrow">
          <svg viewBox="0 0 220 40" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="arrowShaft" x1="0" x2="1" y1="0" y2="0">
                <stop offset="0" stop-color="#3d2a18"/>
                <stop offset="0.4" stop-color="#7b4b2a"/>
                <stop offset="0.7" stop-color="#3a2314"/>
                <stop offset="1" stop-color="#2a1a0e"/>
              </linearGradient>
              <linearGradient id="arrowHead" x1="0" x2="1" y1="0" y2="0">
                <stop offset="0" stop-color="#f1f5f9"/>
                <stop offset="0.5" stop-color="#b0bccd"/>
                <stop offset="1" stop-color="#7a8698"/>
              </linearGradient>
            </defs>
            <rect x="34" y="17" width="140" height="6" rx="3" fill="url(#arrowShaft)"/>
            <rect x="34" y="16" width="140" height="2" rx="1" fill="rgba(255,255,255,0.25)"/>
            <path d="M174 12 L214 20 L174 28 Z" fill="url(#arrowHead)" stroke="#516173" stroke-width="1"/>
            <path d="M28 14 L42 20 L28 26 Z" fill="#f8fafc" stroke="#94a3b8" stroke-width="1"/>
            <path d="M8 10 C18 12 24 16 26 20 C24 24 18 28 8 30" fill="#e2e8f0"/>
            <path d="M12 8 C22 11 30 16 32 20 C30 24 22 29 12 32" fill="#cbd5f5"/>
            <path d="M6 14 C14 16 18 18 20 20 C18 22 14 24 6 26" fill="#94a3b8"/>
          </svg>
        </div>
        <div class="win-modal-backdrop" id="winModalBackdrop"></div>
        <div class="win-modal" id="winModal" role="dialog" aria-modal="true">
          <button class="win-modal__close" type="button" aria-label="–ó–∞–∫—Ä—ã—Ç—å">√ó</button>
          <div class="win-modal__title">–§–æ—Ä—Ç—É–Ω–∞ —Å–µ–≥–æ–¥–Ω—è –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ!üéâ</div>
          <div class="win-modal__prize" id="winPrizeText">–í–∞—à –ø—Ä–∏–∑: ‚Äî</div>
          <div class="win-modal__sector" id="winSectorText">–°–µ–∫—Ç–æ—Ä: ‚Äî</div>
          <button class="win-modal__button" id="winClaimBtn">–ó–∞–±—Ä–∞—Ç—å –ø—Ä–∏–∑</button>
        </div>
      </div>
    </div>

    <div class="grid">
      <button id="spinBtn">–ö—Ä—É—Ç–∏—Ç—å</button>
      <div class="result" id="result">–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚Äî</div>
      <div class="small" id="debug"></div>
    </div>
  </div>

  <script>
  const tg = window.Telegram?.WebApp;
    // ====== Sound (Web Audio) ======
let audioCtx = null;
let soundEnabled = true;
let lastTickStep = null;
let tickGain = null;
let metalGain = null;
let winGain = null;
let bowDrawGain = null;
let bowReleaseGain = null;
let bowImpactGain = null;
let limiter = null;

function ensureAudio() {
  try {
    if (!soundEnabled) return null;
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      limiter = audioCtx.createDynamicsCompressor();
      limiter.threshold.setValueAtTime(-16, audioCtx.currentTime);
      limiter.knee.setValueAtTime(6, audioCtx.currentTime);
      limiter.ratio.setValueAtTime(10, audioCtx.currentTime);
      limiter.attack.setValueAtTime(0.004, audioCtx.currentTime);
      limiter.release.setValueAtTime(0.08, audioCtx.currentTime);

      tickGain = audioCtx.createGain();
      metalGain = audioCtx.createGain();
      winGain = audioCtx.createGain();
      bowDrawGain = audioCtx.createGain();
      bowReleaseGain = audioCtx.createGain();
      bowImpactGain = audioCtx.createGain();

      tickGain.gain.value = 0.08;
      metalGain.gain.value = 0.035;
      winGain.gain.value = 0.12;
      bowDrawGain.gain.value = 0.02;
      bowReleaseGain.gain.value = 0.045;
      bowImpactGain.gain.value = 0.03;

      tickGain.connect(limiter);
      metalGain.connect(limiter);
      winGain.connect(limiter);
      bowDrawGain.connect(limiter);
      bowReleaseGain.connect(limiter);
      bowImpactGain.connect(limiter);
      limiter.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  } catch (error) {
    console.warn("Audio init failed:", error);
    return null;
  }
}

function playTick() {
  try {
    const ac = ensureAudio();
    if (!ac) return;

    const o = ac.createOscillator();
    const g = ac.createGain();
    const metal = ac.createOscillator();
    const metalEnv = ac.createGain();

    o.type = "square";
    o.frequency.value = 1200;
    metal.type = "triangle";
    metal.frequency.value = 3200;

    const now = ac.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.8, now + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.045);

    metalEnv.gain.setValueAtTime(0.0001, now);
    metalEnv.gain.exponentialRampToValueAtTime(0.7, now + 0.002);
    metalEnv.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);

    o.connect(g);
    g.connect(tickGain);
    metal.connect(metalEnv);
    metalEnv.connect(metalGain);
    o.start(now);
    metal.start(now);
    o.stop(now + 0.05);
    metal.stop(now + 0.04);
  } catch (error) {
    console.warn("Tick sound failed:", error);
  }
}

function playWin() {
  try {
    const ac = ensureAudio();
    if (!ac) return;

    const o = ac.createOscillator();
    const g = ac.createGain();

    o.type = "sine";

    const now = ac.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);

    o.frequency.setValueAtTime(880, now);
    o.frequency.setValueAtTime(1320, now + 0.08);
    o.frequency.setValueAtTime(990, now + 0.16);

    o.connect(g);
    g.connect(winGain);
    o.start(now);
    o.stop(now + 0.28);
  } catch (error) {
    console.warn("Win sound failed:", error);
  }
}

function playBowDraw() {
  try {
    const ac = ensureAudio();
    if (!ac) return;
    const now = ac.currentTime;
    const osc = ac.createOscillator();
    const mod = ac.createOscillator();
    const modGain = ac.createGain();
    const filter = ac.createBiquadFilter();
    const gain = ac.createGain();

    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(140, now);
    osc.frequency.exponentialRampToValueAtTime(90, now + 0.35);

    mod.type = "sine";
    mod.frequency.setValueAtTime(6, now);
    modGain.gain.setValueAtTime(18, now);
    mod.connect(modGain);
    modGain.connect(osc.frequency);

    filter.type = "lowpass";
    filter.frequency.setValueAtTime(650, now);
    filter.frequency.exponentialRampToValueAtTime(420, now + 0.35);

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.6, now + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.36);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(bowDrawGain);

    osc.start(now);
    mod.start(now);
    osc.stop(now + 0.38);
    mod.stop(now + 0.38);
  } catch (error) {
    console.warn("Bow draw sound failed:", error);
  }
}

function playBowRelease() {
  try {
    const ac = ensureAudio();
    if (!ac) return;
    const now = ac.currentTime;
    const osc = ac.createOscillator();
    const gain = ac.createGain();

    osc.type = "triangle";
    osc.frequency.setValueAtTime(980, now);
    osc.frequency.exponentialRampToValueAtTime(320, now + 0.12);

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.7, now + 0.012);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.14);

    osc.connect(gain);
    gain.connect(bowReleaseGain);
    osc.start(now);
    osc.stop(now + 0.15);
  } catch (error) {
    console.warn("Bow release sound failed:", error);
  }
}

function playBowImpact() {
  try {
    const ac = ensureAudio();
    if (!ac) return;
    const now = ac.currentTime;
    const noise = ac.createBufferSource();
    const buffer = ac.createBuffer(1, ac.sampleRate * 0.15, ac.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i += 1) {
      data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    }
    noise.buffer = buffer;

    const filter = ac.createBiquadFilter();
    filter.type = "bandpass";
    filter.frequency.setValueAtTime(820, now);
    filter.Q.setValueAtTime(2.4, now);

    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.5, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(bowImpactGain);
    noise.start(now);
    noise.stop(now + 0.16);
  } catch (error) {
    console.warn("Bow impact sound failed:", error);
  }
}

  if (tg) {
    tg.ready();
    tg.expand();
    tg.MainButton.hide();
}

    // ====== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ======
    const canvas = document.getElementById("wheel");
    const ctx = canvas.getContext("2d");

    const spinBtn = document.getElementById("spinBtn");
    const resultEl = document.getElementById("result");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const winOverlay = document.getElementById("winOverlay");
    const winBow = document.getElementById("winBow");
    const winArrow = document.getElementById("winArrow");
    const winPrizeText = document.getElementById("winPrizeText");
    const winSectorText = document.getElementById("winSectorText");
    const winModal = document.getElementById("winModal");
    const winModalBackdrop = document.getElementById("winModalBackdrop");
    const winClaimBtn = document.getElementById("winClaimBtn");
    const winModalClose = winModal?.querySelector(".win-modal__close");

    const itemsInput = document.getElementById("itemsInput");
    const seedInput = document.getElementById("seedInput");

    let items = parseItems(itemsInput.value);
    let angle = 0;          // —Ç–µ–∫—É—â–∏–π —É–≥–æ–ª –≤—Ä–∞—â–µ–Ω–∏—è
    let spinning = false;
    let winTimeouts = [];
    let lastWin = null;

    // –í–∏–∑—É–∞–ª
    const size = canvas.width;
    const cx = size / 2;
    const cy = size / 2;
    const r = size / 2 - 8;

    // ====== Win Effects ======
    function clearWinEffects() {
      if (!winArrow || !winOverlay || !winPrizeText || !winModal || !winBow) return;
      winTimeouts.forEach((timeout) => window.clearTimeout(timeout));
      winTimeouts = [];
      winArrow.classList.remove("is-animating", "is-active", "is-nocked");
      winBow.classList.remove("is-visible");
      winOverlay.classList.remove("is-drawing", "is-modal-open");
      winPrizeText.textContent = "–í–∞—à –ø—Ä–∏–∑: ‚Äî";
      if (winSectorText) winSectorText.textContent = "–°–µ–∫—Ç–æ—Ä: ‚Äî";
      winArrow.style.animation = "none";
      winArrow.offsetHeight;
      winArrow.style.animation = "";
    }

    function computeTargetPoint(idx, count, wheelRadius, finalAngle) {
      const slice = (Math.PI * 2) / count;
      const targetAngle = finalAngle + idx * slice + slice / 2;
      const radius = wheelRadius * 0.7;
      const targetX = cx + Math.cos(targetAngle) * radius;
      const targetY = cy + Math.sin(targetAngle) * radius;
      const rect = winOverlay.getBoundingClientRect();
      const scale = rect.width / canvas.width;
      return {
        x: targetX * scale,
        y: targetY * scale,
        scale
      };
    }

    function getBowAnchorPoint() {
      const bowRect = winBow.getBoundingClientRect();
      const overlayRect = winOverlay.getBoundingClientRect();
      return {
        x: bowRect.left + bowRect.width * 0.72 - overlayRect.left,
        y: bowRect.top + bowRect.height * 0.52 - overlayRect.top
      };
    }

    function showWinModal({ idx, prize, items }) {
      if (!winOverlay || !winModal || !winPrizeText) return;
      winPrizeText.textContent = `–í–∞—à –ø—Ä–∏–∑: ${prize}`;
      if (winSectorText) {
        winSectorText.textContent = `–°–µ–∫—Ç–æ—Ä: #${idx + 1} –∏–∑ ${items.length}`;
      }
      winOverlay.classList.add("is-modal-open");
    }

    function claimPrize() {
      if (!lastWin) return;
      const payload = { prize: lastWin.prize, idx: lastWin.idx, items: lastWin.items };
      if (tg) {
        tg.sendData(JSON.stringify(payload));
      } else {
        console.log("Claim prize:", payload);
      }
      winOverlay?.classList.remove("is-modal-open");
    }

    function shootSequence({ idx, prize, items }) {
      if (!winArrow || !winBow || !winOverlay) return;
      const overlayRect = winOverlay.getBoundingClientRect();
      const start = getBowAnchorPoint();
      const target = computeTargetPoint(idx, items.length, r, angle);
      const endX = target.x;
      const endY = target.y;
      const midX = (start.x + endX) / 2 - overlayRect.width * 0.06;
      const midY = (start.y + endY) / 2 - overlayRect.height * 0.18;

      const startRot = Math.atan2(endY - start.y, endX - start.x) * (180 / Math.PI);
      const midRot = Math.atan2(endY - midY, endX - midX) * (180 / Math.PI);
      const endRot = midRot;

      winArrow.style.setProperty("--bow-x", `${start.x}px`);
      winArrow.style.setProperty("--bow-y", `${start.y}px`);
      winArrow.style.setProperty("--bow-rot", `${startRot}deg`);
      winArrow.style.setProperty("--start-x", `${start.x}px`);
      winArrow.style.setProperty("--start-y", `${start.y}px`);
      winArrow.style.setProperty("--mid-x", `${midX}px`);
      winArrow.style.setProperty("--mid-y", `${midY}px`);
      winArrow.style.setProperty("--end-x", `${endX}px`);
      winArrow.style.setProperty("--end-y", `${endY}px`);
      winArrow.style.setProperty("--start-rot", `${startRot}deg`);
      winArrow.style.setProperty("--mid-rot", `${midRot}deg`);
      winArrow.style.setProperty("--end-rot", `${endRot}deg`);

      winBow.classList.add("is-visible");
      winOverlay.classList.add("is-drawing");
      winArrow.classList.add("is-active", "is-nocked");

      const drawDuration = 340;
      const releaseDelay = drawDuration + 60;
      const impactDelay = releaseDelay + 720;
      const modalDelay = releaseDelay + 980;

      playBowDraw();

      winTimeouts.push(window.setTimeout(() => {
        winOverlay.classList.remove("is-drawing");
      }, drawDuration));

      winTimeouts.push(window.setTimeout(() => {
        winArrow.classList.remove("is-nocked");
        winArrow.classList.add("is-animating");
        playBowRelease();
      }, releaseDelay));

      winTimeouts.push(window.setTimeout(() => {
        winBow.classList.remove("is-visible");
      }, releaseDelay + 350));

      winTimeouts.push(window.setTimeout(() => {
        playBowImpact();
      }, impactDelay));

      winTimeouts.push(window.setTimeout(() => {
        showWinModal({ idx, prize, items });
      }, modalDelay));
    }

    function runWinEffects({ idx, prize, items }) {
      if (!winArrow || !winOverlay || !winPrizeText) return;
      clearWinEffects();
      lastWin = { idx, prize, items };
      shootSequence({ idx, prize, items });
    }

    winModalClose?.addEventListener("click", (event) => {
      event.stopPropagation();
      winOverlay?.classList.remove("is-modal-open");
    });
    winModalBackdrop?.addEventListener("click", () => {
      winOverlay?.classList.remove("is-modal-open");
    });
    winClaimBtn?.addEventListener("click", (event) => {
      event.preventDefault();
      claimPrize();
    });

    // ====== –†–µ–Ω–¥–µ—Ä –∫–æ–ª–µ—Å–∞ ======
    let woodNoisePattern = null;

    function getWoodNoisePattern() {
      if (woodNoisePattern) return woodNoisePattern;
      const noiseCanvas = document.createElement("canvas");
      const noiseSize = 140;
      noiseCanvas.width = noiseSize;
      noiseCanvas.height = noiseSize;
      const nctx = noiseCanvas.getContext("2d");
      const imageData = nctx.createImageData(noiseSize, noiseSize);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const shade = 110 + Math.random() * 70;
        data[i] = shade;
        data[i + 1] = shade - 12;
        data[i + 2] = shade - 26;
        data[i + 3] = 32 + Math.random() * 60;
      }
      nctx.putImageData(imageData, 0, 0);
      nctx.strokeStyle = "rgba(90,60,30,0.18)";
      nctx.lineWidth = 1;
      for (let i = 0; i < 16; i++) {
        const y = (i + 1) * 8;
        nctx.beginPath();
        nctx.moveTo(0, y);
        nctx.bezierCurveTo(noiseSize * 0.3, y - 2, noiseSize * 0.6, y + 2, noiseSize, y);
        nctx.stroke();
      }
      woodNoisePattern = ctx.createPattern(noiseCanvas, "repeat");
      return woodNoisePattern;
    }

    function drawWheel() {
      ctx.clearRect(0, 0, size, size);

      const n = items.length;
      const slice = (Math.PI * 2) / n;
      const innerRadius = r * 0.22;

      for (let i = 0; i < n; i++) {
        const start = angle + i * slice;
        const end = start + slice;
        const mid = start + slice / 2;
        const hueShift = ((i * 7) % 12) - 6;
        const baseHue = 28 + hueShift;
        const baseLight = `hsl(${baseHue}, 48%, 58%)`;
        const baseMid = `hsl(${baseHue - 2}, 52%, 44%)`;
        const baseDark = `hsl(${baseHue - 4}, 56%, 32%)`;

        const grad = ctx.createRadialGradient(cx, cy, r * 0.08, cx, cy, r);
        grad.addColorStop(0, "rgba(255,248,236,0.9)");
        grad.addColorStop(0.28, baseLight);
        grad.addColorStop(0.62, baseMid);
        grad.addColorStop(1, baseDark);

        // —Ü–≤–µ—Ç —Å–µ–∫—Ç–æ—Ä–∞
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();

        // —Ç–µ–∫—Å—Ç—É—Ä–∞ –¥–µ—Ä–µ–≤–∞
        ctx.save();
        ctx.fillStyle = getWoodNoisePattern();
        ctx.globalAlpha = 0.2;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.lineWidth = 1;
        for (let ring = 0; ring < 3; ring++) {
          const ringRadius = r - 16 - ring * 14;
          ctx.beginPath();
          ctx.arc(cx, cy, ringRadius, start, end);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = "multiply";
        ctx.strokeStyle = "rgba(60,40,20,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        ctx.save();
        const sheen = ctx.createRadialGradient(cx, cy, innerRadius * 0.2, cx, cy, r * 0.7);
        sheen.addColorStop(0, "rgba(255,255,255,0.25)");
        sheen.addColorStop(0.5, "rgba(255,255,255,0)");
        ctx.fillStyle = sheen;
        ctx.globalCompositeOperation = "screen";
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // —Ç–µ–∫—Å—Ç
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(start + slice / 2);
        ctx.textAlign = "right";
        ctx.fillStyle = "#f7efe2";
        ctx.shadowColor = "rgba(0,0,0,0.45)";
        ctx.shadowBlur = 4;
        ctx.font = "bold 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(items[i], r - 14, 6);
        ctx.restore();
      }

      // –±—Ä–æ–Ω–∑–æ–≤—ã–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏
      ctx.save();
      ctx.lineWidth = 2.6;
      for (let i = 0; i < n; i++) {
        const lineAngle = angle + i * slice;
        const x1 = cx + Math.cos(lineAngle) * innerRadius;
        const y1 = cy + Math.sin(lineAngle) * innerRadius;
        const x2 = cx + Math.cos(lineAngle) * r;
        const y2 = cy + Math.sin(lineAngle) * r;
        const metalLine = ctx.createLinearGradient(x1, y1, x2, y2);
        metalLine.addColorStop(0, "#6d461d");
        metalLine.addColorStop(0.4, "#e0b165");
        metalLine.addColorStop(1, "#8a5b25");
        ctx.strokeStyle = metalLine;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();

      // –±—Ä–æ–Ω–∑–æ–≤–∞—è –æ–∫–∞–Ω—Ç–æ–≤–∫–∞
      const rimGradient = ctx.createRadialGradient(cx, cy, r * 0.72, cx, cy, r + 10);
      rimGradient.addColorStop(0, "#6a3f17");
      rimGradient.addColorStop(0.38, "#b97a34");
      rimGradient.addColorStop(0.55, "#f0c97a");
      rimGradient.addColorStop(0.72, "#b97a34");
      rimGradient.addColorStop(1, "#4a2d12");
      ctx.beginPath();
      ctx.arc(cx, cy, r + 3, 0, Math.PI * 2);
      ctx.strokeStyle = rimGradient;
      ctx.lineWidth = 12;
      ctx.stroke();

      ctx.save();
      const rimHighlight = ctx.createLinearGradient(cx - r, cy - r, cx + r, cy + r);
      rimHighlight.addColorStop(0, "rgba(255,255,255,0)");
      rimHighlight.addColorStop(0.5, "rgba(255,236,196,0.35)");
      rimHighlight.addColorStop(1, "rgba(255,255,255,0)");
      ctx.strokeStyle = rimHighlight;
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(cx, cy, r + 3, -Math.PI * 0.2, Math.PI * 0.7);
      ctx.stroke();
      ctx.restore();

      // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∫–æ–ª—å—Ü–æ
      const innerGradient = ctx.createRadialGradient(cx, cy, innerRadius * 0.3, cx, cy, innerRadius);
      innerGradient.addColorStop(0, "#d4b07a");
      innerGradient.addColorStop(1, "#8b5a2c");
      ctx.beginPath();
      ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
      ctx.strokeStyle = innerGradient;
      ctx.lineWidth = 6;
      ctx.stroke();

      // —Ü–µ–Ω—Ç—Ä
      ctx.beginPath();
      ctx.arc(cx, cy, 24, 0, Math.PI * 2);
      ctx.fillStyle = "#f2e6cf";
      ctx.fill();
      ctx.strokeStyle = "#6b4a23";
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // ====== –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–µ–∫—Ç–æ—Ä–∞ (–∫—É–¥–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç—Ä–µ–ª–∫–∞ —Å–≤–µ—Ä—Ö—É) ======
    function pickIndex() {
      const n = items.length;
      const slice = (Math.PI * 2) / n;

      // –°—Ç—Ä–µ–ª–∫–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å–≤–µ—Ä—Ö—É (—É–≥–æ–ª -90¬∞), –Ω–æ –≤ canvas 0 —Ä–∞–¥ —Å–ø—Ä–∞–≤–∞.
      // –ü–æ—ç—Ç–æ–º—É —Å–¥–≤–∏–≥–∞–µ–º —Ç–∞–∫, —á—Ç–æ–±—ã "–≤–µ—Ä—Ö" –±—ã–ª —Ç–æ—á–∫–æ–π –≤—ã–±–æ—Ä–∞:
      const pointerAngle = -Math.PI / 2;

      // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —É–≥–æ–ª: –∫–∞–∫–æ–π —Å–µ–∫—Ç–æ—Ä —Å–µ–π—á–∞—Å –ø–æ–¥ —Å—Ç—Ä–µ–ª–∫–æ–π
      let a = (pointerAngle - angle) % (Math.PI * 2);
      if (a < 0) a += Math.PI * 2;

      const idx = Math.floor(a / slice);
      return idx;
    }

    // ====== –ü—Ä–æ—Å—Ç–µ–Ω—å–∫–∏–π RNG (–µ—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–≤—Ç–æ—Ä—è–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã) ======
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let x = Math.imul(t ^ (t >>> 15), 1 | t);
        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function parseItems(text) {
      const arr = text.split(",").map(s => s.trim()).filter(Boolean);
      return arr.length ? arr : ["–ü—Ä–∏–∑ 1", "–ü—Ä–∏–∑ 2", "–ü—Ä–∏–∑ 3"];
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    // ====== –ê–Ω–∏–º–∞—Ü–∏—è –≤—Ä–∞—â–µ–Ω–∏—è ======
    function spin() {
      if (spinning) return;

      items = parseItems(itemsInput.value);
      drawWheel();
      clearWinEffects();

      spinning = true;
      lastTickStep = null;


      if (tg) tg.MainButton.hide();

      spinBtn.disabled = true;
      setStatus("–ö—Ä—É—Ç–∏–º‚Ä¶");

      // RNG: –ª–∏–±–æ —Å–∏–¥, –ª–∏–±–æ –æ–±—ã—á–Ω—ã–π Math.random
      const seedVal = seedInput.value.trim();
      const rnd = seedVal ? mulberry32(Number(seedVal) || 123) : Math.random;

      // –•–æ—Ç–∏–º 4..7 –ø–æ–ª–Ω—ã—Ö –æ–±–æ—Ä–æ—Ç–æ–≤ + –¥–æ–∫—Ä—É—Ç–∫–∞
      const extraTurns = 4 + Math.floor((seedVal ? rnd() : Math.random()) * 4);
      const target = angle + extraTurns * Math.PI * 2 + (seedVal ? rnd() : Math.random()) * Math.PI * 2;

      const start = angle;
      const delta = target - start;

      const duration = 2600; // –º—Å
      const t0 = performance.now();

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function frame(now) {
        const t = Math.min(1, (now - t0) / duration);
        const eased = easeOutCubic(t);
        angle = start + delta * eased;
        const n = items.length;
const step = (Math.PI * 2) / (n * 2);
const tickStep = Math.floor(angle / step);

if (tickStep !== lastTickStep) {
  lastTickStep = tickStep;
  playTick();
      }


        drawWheel();

        if (t < 1) {
          requestAnimationFrame(frame);
        } else {
          // –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
          angle = angle % (Math.PI * 2);
          const idx = pickIndex();
          const prize = items[idx];

          resultEl.textContent = "–†–µ–∑—É–ª—å—Ç–∞—Ç: " + prize;
          playWin();
          runWinEffects({ idx, prize, items });


if (tg) {
  tg.MainButton.setText("–ó–∞–±—Ä–∞—Ç—å –ø—Ä–∏–∑");
  tg.MainButton.show();

  // —á—Ç–æ–±—ã –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ –Ω–∞–∫–∞–ø–ª–∏–≤–∞–ª—Å—è –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –≤—Ä–∞—â–µ–Ω–∏—è—Ö
  tg.MainButton.offClick?.();

  tg.MainButton.onClick(() => {
    tg.sendData(JSON.stringify({ prize, idx, items }));
    // tg.close(); // –≤–∫–ª—é—á–∏—à—å –ø–æ–∑–∂–µ, –µ—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å –∑–∞–∫—Ä—ã–≤–∞—Ç—å –æ–∫–Ω–æ
  });
}

debugEl.textContent = `–°–µ–∫—Ç–æ—Ä #${idx + 1} –∏–∑ ${items.length}`;


          setStatus("–ì–æ—Ç–æ–≤–æ");
          spinning = false;
          spinBtn.disabled = false;
        }
      }

      requestAnimationFrame(frame);
    }

    // ====== –°–æ–±—ã—Ç–∏—è ======
    spinBtn.addEventListener("click", () => {
  ensureAudio();
  spin();
    });

    itemsInput.addEventListener("change", () => {
      items = parseItems(itemsInput.value);
      drawWheel();
    });

    // –ø–µ—Ä–≤—ã–π —Ä–µ–Ω–¥–µ—Ä
    drawWheel();
  </script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

</body>
</html>


