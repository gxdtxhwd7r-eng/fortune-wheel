<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–ö–æ–ª–µ—Å–æ —Ñ–æ—Ä—Ç—É–Ω—ã</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 0; background: #0b0f19; color: #e8eefc; display: grid; place-items: center; min-height: 100vh; }
    .card { width: min(520px, 92vw); background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 18px; padding: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; gap: 14px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .wheel-wrap { position: relative; display: grid; place-items: center; gap: 10px; margin-top: 12px; }
    canvas { background: transparent; }
    #swordPointer {
      position: absolute;
      top: -6px;
      left: 50%;
      width: 72px;
      transform: translateX(-50%) rotate(0deg);
      transform-origin: 50% 20%;
      z-index: 3;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.45));
      pointer-events: none;
    }
    #swordPointer svg { width: 100%; height: auto; display: block; }
    .win-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 4;
    }
    .win-bow {
      position: absolute;
      top: 6%;
      left: 6%;
      width: clamp(120px, 26vw, 170px);
      opacity: 0;
      transform: translateY(-10px) scale(0.95);
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.45));
      transition: opacity 180ms ease, transform 220ms ease;
      pointer-events: none;
    }
    .win-bow svg { width: 100%; height: auto; display: block; }
    .win-bow.is-visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .bow-string {
      transform-origin: 60% 50%;
      transition: transform 260ms ease;
    }
    .bow-limb {
      transform-origin: 50% 50%;
      transition: transform 260ms ease;
    }
    .win-arrow {
      position: absolute;
      width: clamp(120px, 30vw, 170px);
      height: auto;
      opacity: 0;
      transform-origin: 82% 50%;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.45));
      pointer-events: none;
    }
    .win-arrow svg { width: 100%; height: 100%; display: block; }
    .win-arrow.is-active { opacity: 1; }
    .win-arrow.is-nocked {
      opacity: 1;
      transform: translate(var(--bow-x), var(--bow-y)) translate(-82%, -50%) rotate(var(--bow-rot));
      transition: transform 260ms ease, opacity 120ms ease;
    }
    .win-overlay.is-drawing .win-arrow.is-nocked {
      transform: translate(var(--bow-x), var(--bow-y)) translate(-82%, -50%) rotate(var(--bow-rot)) translateX(-20px);
    }
    .win-overlay.is-drawing .bow-string {
      transform: translateX(-10px);
    }
    .win-overlay.is-drawing .bow-limb.left {
      transform: rotate(-1.2deg);
    }
    .win-overlay.is-drawing .bow-limb.right {
      transform: rotate(1.2deg);
    }
    .win-arrow.is-animating {
      animation:
        arrow-flight 700ms cubic-bezier(0.2, 0.7, 0.2, 1) forwards,
        arrow-impact 220ms 700ms ease-out forwards;
    }
    @keyframes arrow-flight {
      0% {
        transform: translate(var(--start-x), var(--start-y)) translate(-84%, -50%) rotate(var(--start-rot));
      }
      70% {
        transform: translate(var(--mid-x), var(--mid-y)) translate(-84%, -50%) rotate(var(--mid-rot));
      }
      100% {
        transform: translate(var(--end-x), var(--end-y)) translate(-84%, -50%) rotate(var(--end-rot));
      }
    }
    @keyframes arrow-impact {
      0% {
        transform: translate(var(--end-x), var(--end-y)) translate(-84%, -50%) rotate(var(--end-rot));
      }
      60% {
        transform: translate(var(--end-x), var(--end-y)) translate(-84%, -50%) rotate(calc(var(--end-rot) + 3deg)) scale(1.04);
      }
      100% {
        transform: translate(var(--end-x), var(--end-y)) translate(-84%, -50%) rotate(var(--end-rot)) scale(1);
      }
    }
    .win-modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(5, 8, 18, 0.72);
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: auto;
    }
    .win-modal {
      position: absolute;
      left: 50%;
      top: 50%;
      width: min(92%, 420px);
      transform: translate(-50%, -50%) scale(0.92);
      background: linear-gradient(180deg, #ffffff 0%, #f4f7ff 100%);
      color: #0f172a;
      border-radius: 24px;
      padding: 26px 22px 22px;
      box-shadow: 0 25px 60px rgba(0,0,0,0.35);
      opacity: 0;
      transition: opacity 220ms ease, transform 240ms ease;
      pointer-events: auto;
    }
    .win-modal__title {
      font-size: 20px;
      font-weight: 800;
      margin-bottom: 10px;
      text-align: center;
    }
    .win-modal__prize {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 6px;
      text-align: center;
    }
    .win-modal__sector {
      font-size: 14px;
      color: #475569;
      text-align: center;
      margin-bottom: 18px;
    }
    .win-modal__close {
      position: absolute;
      top: 12px;
      right: 14px;
      border: 0;
      background: rgba(15, 23, 42, 0.08);
      color: #0f172a;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
    }
    .win-modal__button {
      width: 100%;
      background: #2563eb;
      padding: 14px 16px;
      font-size: 16px;
      border-radius: 14px;
      box-shadow: 0 12px 24px rgba(37,99,235,0.3);
    }
    .win-overlay.is-modal-open {
      pointer-events: auto;
    }
    .win-overlay.is-modal-open .win-modal-backdrop,
    .win-overlay.is-modal-open .win-modal {
      opacity: 1;
    }
    .win-overlay.is-modal-open .win-modal {
      transform: translate(-50%, -50%) scale(1);
    }
    button {
      appearance: none; border: 0; cursor: pointer;
      background: #3b82f6; color: white; font-weight: 700;
      padding: 12px 14px; border-radius: 12px;
      box-shadow: 0 10px 20px rgba(59,130,246,.25);
      transition: transform .05s ease;
      width: 100%;
    }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .small { opacity: .8; font-size: 13px; line-height: 1.35; }
    .result { margin-top: 10px; font-size: 16px; font-weight: 700; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .grid { display:grid; gap: 10px; }
    .inputs { display:flex; gap: 10px; flex-wrap: wrap; }
    input {
      flex: 1 1 160px;
      padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25); color: #e8eefc;
      outline: none;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="row">
      <h1>üé° –ö–æ–ª–µ—Å–æ —Ñ–æ—Ä—Ç—É–Ω—ã</h1>
      <span class="pill" id="status">–ì–æ—Ç–æ–≤–æ</span>
    </div>

    <div class="small">
      –í–≤–µ–¥–∏ –ø—Ä–∏–∑—ã —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é –∏ –∂–º–∏ ¬´–ö—Ä—É—Ç–∏—Ç—å¬ª.
    </div>

    <div class="inputs" style="margin-top: 12px;">
      <input id="itemsInput" placeholder="(–≤–≤–µ–¥–∏ –ø—Ä–∏–∑—ã —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)" />
      <input id="seedInput" placeholder="(–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) —Å–∏–¥, –Ω–∞–ø—Ä–∏–º–µ—Ä 123" />
    </div>

    <div class="wheel-wrap">
      <div id="swordPointer" aria-hidden="true">
        <svg viewBox="0 0 120 200" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="bladeGrad" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0" stop-color="#f6f8fb"/>
              <stop offset="0.35" stop-color="#d9e1ec"/>
              <stop offset="0.55" stop-color="#b8c2d1"/>
              <stop offset="0.75" stop-color="#e6edf6"/>
              <stop offset="1" stop-color="#8f9bac"/>
            </linearGradient>
            <linearGradient id="bladeShine" x1="0" x2="1" y1="0" y2="0">
              <stop offset="0" stop-color="rgba(255,255,255,0)"/>
              <stop offset="0.5" stop-color="rgba(255,255,255,0.55)"/>
              <stop offset="1" stop-color="rgba(255,255,255,0)"/>
            </linearGradient>
            <linearGradient id="hiltGrad" x1="0" x2="1" y1="0" y2="0">
              <stop offset="0" stop-color="#a9742a"/>
              <stop offset="0.45" stop-color="#efc67a"/>
              <stop offset="0.75" stop-color="#c38a3d"/>
              <stop offset="1" stop-color="#6e4318"/>
            </linearGradient>
          </defs>
          <circle cx="60" cy="18" r="10" fill="url(#hiltGrad)" stroke="#6a4a21" stroke-width="2"/>
          <circle cx="60" cy="18" r="4" fill="#3a240f"/>
          <rect x="52" y="28" width="16" height="30" rx="6" fill="#5d3a1c"/>
          <rect x="28" y="60" width="64" height="16" rx="8" fill="url(#hiltGrad)" stroke="#6a4a21" stroke-width="2"/>
          <rect x="52" y="72" width="16" height="10" rx="5" fill="#a9b2c2"/>
          <path d="M54 80 L66 80 L66 156 L60 178 L54 156 Z" fill="url(#bladeGrad)" stroke="#707785" stroke-width="2" stroke-linejoin="round"/>
          <path d="M56.5 84 L63.5 84 L63.5 151 L60 170 L56.5 151 Z" fill="url(#bladeShine)" opacity="0.55"/>
        </svg>
      </div>
      <canvas id="wheel" width="360" height="360"></canvas>
      <div class="win-overlay" id="winOverlay" aria-hidden="true">
        <div class="win-bow" id="winBow">
          <svg viewBox="0 0 220 220" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="bowWood" x1="0" x2="1" y1="0" y2="1">
                <stop offset="0" stop-color="#3b2413"/>
                <stop offset="0.5" stop-color="#7a4a24"/>
                <stop offset="1" stop-color="#2a160a"/>
              </linearGradient>
              <linearGradient id="bowHighlight" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0" stop-color="rgba(255,255,255,0.35)"/>
                <stop offset="1" stop-color="rgba(255,255,255,0)"/>
              </linearGradient>
            </defs>
            <path class="bow-limb left" d="M60 20 C30 70 30 150 60 200" stroke="url(#bowWood)" stroke-width="16" stroke-linecap="round" fill="none"/>
            <path class="bow-limb right" d="M160 20 C190 70 190 150 160 200" stroke="url(#bowWood)" stroke-width="16" stroke-linecap="round" fill="none"/>
            <path d="M60 20 C35 70 35 150 60 200" stroke="url(#bowHighlight)" stroke-width="6" stroke-linecap="round" fill="none" opacity="0.5"/>
            <rect x="96" y="86" width="28" height="48" rx="12" fill="#1f2937" opacity="0.85"/>
            <rect x="100" y="92" width="20" height="36" rx="8" fill="#374151"/>
            <path class="bow-string" d="M64 30 Q110 110 64 190" stroke="#e2e8f0" stroke-width="2" fill="none"/>
            <path class="bow-string" d="M156 30 Q110 110 156 190" stroke="#e2e8f0" stroke-width="2" fill="none"/>
          </svg>
        </div>
        <div class="win-arrow" id="winArrow">
          <svg viewBox="0 0 180 32" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="arrowShaft" x1="0" x2="1" y1="0" y2="0">
                <stop offset="0" stop-color="#3f2d1b"/>
                <stop offset="0.45" stop-color="#5a3b24"/>
                <stop offset="0.7" stop-color="#2d1c10"/>
                <stop offset="1" stop-color="#3b2a1a"/>
              </linearGradient>
              <linearGradient id="arrowHead" x1="0" x2="1" y1="0" y2="0">
                <stop offset="0" stop-color="#cbd5e1"/>
                <stop offset="0.6" stop-color="#94a3b8"/>
                <stop offset="1" stop-color="#64748b"/>
              </linearGradient>
            </defs>
            <rect x="18" y="13" width="122" height="6" rx="3" fill="url(#arrowShaft)"/>
            <rect x="18" y="12" width="122" height="2" rx="1" fill="rgba(255,255,255,0.2)"/>
            <path d="M140 8 L174 16 L140 24 Z" fill="url(#arrowHead)" stroke="#475569" stroke-width="1"/>
            <path d="M14 10 L30 16 L14 22 Z" fill="#f8fafc" stroke="#64748b" stroke-width="1"/>
            <path d="M2 6 C8 6 10 12 10 16 C10 20 8 26 2 26" fill="#cbd5f5"/>
            <path d="M6 6 C12 6 14 12 14 16 C14 20 12 26 6 26" fill="#94a3b8"/>
          </svg>
        </div>
        <div class="win-modal-backdrop" id="winModalBackdrop"></div>
        <div class="win-modal" id="winModal" role="dialog" aria-modal="true">
          <button class="win-modal__close" type="button" aria-label="–ó–∞–∫—Ä—ã—Ç—å">√ó</button>
          <div class="win-modal__title">–§–æ—Ä—Ç—É–Ω–∞ —Å–µ–≥–æ–¥–Ω—è –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ!üéâ</div>
          <div class="win-modal__prize" id="winPrizeText">–í–∞—à –ø—Ä–∏–∑: ‚Äî</div>
          <div class="win-modal__sector" id="winSectorText">–°–µ–∫—Ç–æ—Ä: ‚Äî</div>
          <button class="win-modal__button" id="winClaimBtn">–ó–∞–±—Ä–∞—Ç—å –ø—Ä–∏–∑</button>
        </div>
      </div>
    </div>

    <div class="grid">
      <button id="spinBtn">–ö—Ä—É—Ç–∏—Ç—å</button>
      <div class="result" id="result">–†–µ–∑—É–ª—å—Ç–∞—Ç: ‚Äî</div>
      <div class="small" id="debug"></div>
    </div>
  </div>

  <script>
  const tg = window.Telegram?.WebApp;
    // ====== Sound (Web Audio) ======
let audioCtx = null;
let soundEnabled = true;
let lastTickStep = null;
let tickGain = null;
let metalGain = null;
let winGain = null;
let limiter = null;

function ensureAudio() {
  try {
    if (!soundEnabled) return null;
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      limiter = audioCtx.createDynamicsCompressor();
      limiter.threshold.setValueAtTime(-16, audioCtx.currentTime);
      limiter.knee.setValueAtTime(6, audioCtx.currentTime);
      limiter.ratio.setValueAtTime(10, audioCtx.currentTime);
      limiter.attack.setValueAtTime(0.004, audioCtx.currentTime);
      limiter.release.setValueAtTime(0.08, audioCtx.currentTime);

      tickGain = audioCtx.createGain();
      metalGain = audioCtx.createGain();
      winGain = audioCtx.createGain();

      tickGain.gain.value = 0.08;
      metalGain.gain.value = 0.035;
      winGain.gain.value = 0.12;

      tickGain.connect(limiter);
      metalGain.connect(limiter);
      winGain.connect(limiter);
      limiter.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  } catch (error) {
    console.warn("Audio init failed:", error);
    return null;
  }
}

function playTick() {
  try {
    const ac = ensureAudio();
    if (!ac) return;

    const o = ac.createOscillator();
    const g = ac.createGain();
    const metal = ac.createOscillator();
    const metalEnv = ac.createGain();

    o.type = "square";
    o.frequency.value = 1200;
    metal.type = "triangle";
    metal.frequency.value = 3200;

    const now = ac.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.8, now + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.045);

    metalEnv.gain.setValueAtTime(0.0001, now);
    metalEnv.gain.exponentialRampToValueAtTime(0.7, now + 0.002);
    metalEnv.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);

    o.connect(g);
    g.connect(tickGain);
    metal.connect(metalEnv);
    metalEnv.connect(metalGain);
    o.start(now);
    metal.start(now);
    o.stop(now + 0.05);
    metal.stop(now + 0.04);
  } catch (error) {
    console.warn("Tick sound failed:", error);
  }
}

function playWin() {
  try {
    const ac = ensureAudio();
    if (!ac) return;

    const o = ac.createOscillator();
    const g = ac.createGain();

    o.type = "sine";

    const now = ac.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);

    o.frequency.setValueAtTime(880, now);
    o.frequency.setValueAtTime(1320, now + 0.08);
    o.frequency.setValueAtTime(990, now + 0.16);

    o.connect(g);
    g.connect(winGain);
    o.start(now);
    o.stop(now + 0.28);
  } catch (error) {
    console.warn("Win sound failed:", error);
  }
}

  if (tg) {
    tg.ready();
    tg.expand();
    tg.MainButton.hide();
}

    // ====== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ======
    const canvas = document.getElementById("wheel");
    const ctx = canvas.getContext("2d");

    const spinBtn = document.getElementById("spinBtn");
    const resultEl = document.getElementById("result");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const swordPointer = document.getElementById("swordPointer");
    const winOverlay = document.getElementById("winOverlay");
    const winBow = document.getElementById("winBow");
    const winArrow = document.getElementById("winArrow");
    const winPrizeText = document.getElementById("winPrizeText");
    const winSectorText = document.getElementById("winSectorText");
    const winModal = document.getElementById("winModal");
    const winModalBackdrop = document.getElementById("winModalBackdrop");
    const winClaimBtn = document.getElementById("winClaimBtn");
    const winModalClose = winModal?.querySelector(".win-modal__close");

    const itemsInput = document.getElementById("itemsInput");
    const seedInput = document.getElementById("seedInput");

    let items = parseItems(itemsInput.value);
    let angle = 0;          // —Ç–µ–∫—É—â–∏–π —É–≥–æ–ª –≤—Ä–∞—â–µ–Ω–∏—è
    let spinning = false;
    let swordTicking = false;
    let winTimeouts = [];
    let lastWin = null;

    // –í–∏–∑—É–∞–ª
    const size = canvas.width;
    const cx = size / 2;
    const cy = size / 2;
    const r = size / 2 - 8;

    function swordTick(strength = 1) {
      if (!swordPointer || swordTicking) return;
      swordTicking = true;
      const clamped = Math.min(1.4, Math.max(0.6, strength));
      const maxTilt = -18 * clamped;
      const base = "translateX(-50%) rotate(0deg)";
      const kick = `translateX(-50%) rotate(${maxTilt}deg)`;

      if (typeof swordPointer.animate !== "function") {
        swordPointer.style.transform = kick;
        setTimeout(() => {
          swordPointer.style.transform = base;
          swordTicking = false;
        }, 200);
        return;
      }

      const animation = swordPointer.animate(
        [{ transform: base }, { transform: kick }, { transform: base }],
        { duration: 240, easing: "cubic-bezier(0.25, 0.6, 0.2, 1.4)" }
      );
      animation.onfinish = () => { swordTicking = false; };
      animation.oncancel = () => { swordTicking = false; };
    }

    // ====== Win Effects ======
    function clearWinEffects() {
      if (!winArrow || !winOverlay || !winPrizeText || !winModal || !winBow) return;
      winTimeouts.forEach((timeout) => window.clearTimeout(timeout));
      winTimeouts = [];
      winArrow.classList.remove("is-animating", "is-active", "is-nocked");
      winBow.classList.remove("is-visible");
      winOverlay.classList.remove("is-drawing", "is-modal-open");
      winPrizeText.textContent = "–í–∞—à –ø—Ä–∏–∑: ‚Äî";
      if (winSectorText) winSectorText.textContent = "–°–µ–∫—Ç–æ—Ä: ‚Äî";
      winArrow.style.animation = "none";
      winArrow.offsetHeight;
      winArrow.style.animation = "";
    }

    function computeTargetPoint(idx, count, wheelRadius, finalAngle) {
      const slice = (Math.PI * 2) / count;
      const targetAngle = finalAngle + idx * slice + slice / 2;
      const radius = wheelRadius * 0.7;
      const targetX = cx + Math.cos(targetAngle) * radius;
      const targetY = cy + Math.sin(targetAngle) * radius;
      const rect = winOverlay.getBoundingClientRect();
      const scale = rect.width / canvas.width;
      return {
        x: targetX * scale,
        y: targetY * scale,
        scale
      };
    }

    function getBowAnchorPoint() {
      const bowRect = winBow.getBoundingClientRect();
      const overlayRect = winOverlay.getBoundingClientRect();
      return {
        x: bowRect.left + bowRect.width * 0.78 - overlayRect.left,
        y: bowRect.top + bowRect.height * 0.5 - overlayRect.top
      };
    }

    function showWinModal({ idx, prize, items }) {
      if (!winOverlay || !winModal || !winPrizeText) return;
      winPrizeText.textContent = `–í–∞—à –ø—Ä–∏–∑: ${prize}`;
      if (winSectorText) {
        winSectorText.textContent = `–°–µ–∫—Ç–æ—Ä: #${idx + 1} –∏–∑ ${items.length}`;
      }
      winOverlay.classList.add("is-modal-open");
    }

    function claimPrize() {
      if (!lastWin) return;
      const payload = { prize: lastWin.prize, idx: lastWin.idx, items: lastWin.items };
      if (tg) {
        tg.sendData(JSON.stringify(payload));
      } else {
        console.log("Claim prize:", payload);
      }
      winOverlay?.classList.remove("is-modal-open");
    }

    function shootSequence({ idx, prize, items }) {
      if (!winArrow || !winBow || !winOverlay) return;
      const overlayRect = winOverlay.getBoundingClientRect();
      const start = getBowAnchorPoint();
      const target = computeTargetPoint(idx, items.length, r, angle);
      const endX = target.x;
      const endY = target.y;
      const midX = (start.x + endX) / 2 - overlayRect.width * 0.06;
      const midY = (start.y + endY) / 2 - overlayRect.height * 0.18;

      const startRot = Math.atan2(endY - start.y, endX - start.x) * (180 / Math.PI);
      const midRot = Math.atan2(endY - midY, endX - midX) * (180 / Math.PI);
      const endRot = midRot;

      winArrow.style.setProperty("--bow-x", `${start.x}px`);
      winArrow.style.setProperty("--bow-y", `${start.y}px`);
      winArrow.style.setProperty("--bow-rot", `${startRot}deg`);
      winArrow.style.setProperty("--start-x", `${start.x}px`);
      winArrow.style.setProperty("--start-y", `${start.y}px`);
      winArrow.style.setProperty("--mid-x", `${midX}px`);
      winArrow.style.setProperty("--mid-y", `${midY}px`);
      winArrow.style.setProperty("--end-x", `${endX}px`);
      winArrow.style.setProperty("--end-y", `${endY}px`);
      winArrow.style.setProperty("--start-rot", `${startRot}deg`);
      winArrow.style.setProperty("--mid-rot", `${midRot}deg`);
      winArrow.style.setProperty("--end-rot", `${endRot}deg`);

      winBow.classList.add("is-visible");
      winOverlay.classList.add("is-drawing");
      winArrow.classList.add("is-active", "is-nocked");

      const drawDuration = 320;
      const releaseDelay = drawDuration + 60;
      const modalDelay = releaseDelay + 980;

      winTimeouts.push(window.setTimeout(() => {
        winOverlay.classList.remove("is-drawing");
      }, drawDuration));

      winTimeouts.push(window.setTimeout(() => {
        winArrow.classList.remove("is-nocked");
        winArrow.classList.add("is-animating");
      }, releaseDelay));

      winTimeouts.push(window.setTimeout(() => {
        winBow.classList.remove("is-visible");
      }, releaseDelay + 350));

      winTimeouts.push(window.setTimeout(() => {
        showWinModal({ idx, prize, items });
      }, modalDelay));
    }

    function runWinEffects({ idx, prize, items }) {
      if (!winArrow || !winOverlay || !winPrizeText) return;
      clearWinEffects();
      lastWin = { idx, prize, items };
      shootSequence({ idx, prize, items });
    }

    winModalClose?.addEventListener("click", (event) => {
      event.stopPropagation();
      winOverlay?.classList.remove("is-modal-open");
    });
    winModalBackdrop?.addEventListener("click", () => {
      winOverlay?.classList.remove("is-modal-open");
    });
    winClaimBtn?.addEventListener("click", (event) => {
      event.preventDefault();
      claimPrize();
    });

    // ====== –†–µ–Ω–¥–µ—Ä –∫–æ–ª–µ—Å–∞ ======
    let woodNoisePattern = null;

    function getWoodNoisePattern() {
      if (woodNoisePattern) return woodNoisePattern;
      const noiseCanvas = document.createElement("canvas");
      const noiseSize = 140;
      noiseCanvas.width = noiseSize;
      noiseCanvas.height = noiseSize;
      const nctx = noiseCanvas.getContext("2d");
      const imageData = nctx.createImageData(noiseSize, noiseSize);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const shade = 110 + Math.random() * 70;
        data[i] = shade;
        data[i + 1] = shade - 12;
        data[i + 2] = shade - 26;
        data[i + 3] = 32 + Math.random() * 60;
      }
      nctx.putImageData(imageData, 0, 0);
      nctx.strokeStyle = "rgba(90,60,30,0.18)";
      nctx.lineWidth = 1;
      for (let i = 0; i < 16; i++) {
        const y = (i + 1) * 8;
        nctx.beginPath();
        nctx.moveTo(0, y);
        nctx.bezierCurveTo(noiseSize * 0.3, y - 2, noiseSize * 0.6, y + 2, noiseSize, y);
        nctx.stroke();
      }
      woodNoisePattern = ctx.createPattern(noiseCanvas, "repeat");
      return woodNoisePattern;
    }

    function drawWheel() {
      ctx.clearRect(0, 0, size, size);

      const n = items.length;
      const slice = (Math.PI * 2) / n;
      const innerRadius = r * 0.22;

      for (let i = 0; i < n; i++) {
        const start = angle + i * slice;
        const end = start + slice;
        const mid = start + slice / 2;
        const hueShift = ((i * 7) % 12) - 6;
        const baseHue = 28 + hueShift;
        const baseLight = `hsl(${baseHue}, 48%, 58%)`;
        const baseMid = `hsl(${baseHue - 2}, 52%, 44%)`;
        const baseDark = `hsl(${baseHue - 4}, 56%, 32%)`;

        const grad = ctx.createRadialGradient(cx, cy, r * 0.08, cx, cy, r);
        grad.addColorStop(0, "rgba(255,248,236,0.9)");
        grad.addColorStop(0.28, baseLight);
        grad.addColorStop(0.62, baseMid);
        grad.addColorStop(1, baseDark);

        // —Ü–≤–µ—Ç —Å–µ–∫—Ç–æ—Ä–∞
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();

        // —Ç–µ–∫—Å—Ç—É—Ä–∞ –¥–µ—Ä–µ–≤–∞
        ctx.save();
        ctx.fillStyle = getWoodNoisePattern();
        ctx.globalAlpha = 0.2;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.lineWidth = 1;
        for (let ring = 0; ring < 3; ring++) {
          const ringRadius = r - 16 - ring * 14;
          ctx.beginPath();
          ctx.arc(cx, cy, ringRadius, start, end);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = "multiply";
        ctx.strokeStyle = "rgba(60,40,20,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        ctx.save();
        const sheen = ctx.createRadialGradient(cx, cy, innerRadius * 0.2, cx, cy, r * 0.7);
        sheen.addColorStop(0, "rgba(255,255,255,0.25)");
        sheen.addColorStop(0.5, "rgba(255,255,255,0)");
        ctx.fillStyle = sheen;
        ctx.globalCompositeOperation = "screen";
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // —Ç–µ–∫—Å—Ç
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(start + slice / 2);
        ctx.textAlign = "right";
        ctx.fillStyle = "#f7efe2";
        ctx.shadowColor = "rgba(0,0,0,0.45)";
        ctx.shadowBlur = 4;
        ctx.font = "bold 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(items[i], r - 14, 6);
        ctx.restore();
      }

      // –±—Ä–æ–Ω–∑–æ–≤—ã–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏
      ctx.save();
      ctx.lineWidth = 2.6;
      for (let i = 0; i < n; i++) {
        const lineAngle = angle + i * slice;
        const x1 = cx + Math.cos(lineAngle) * innerRadius;
        const y1 = cy + Math.sin(lineAngle) * innerRadius;
        const x2 = cx + Math.cos(lineAngle) * r;
        const y2 = cy + Math.sin(lineAngle) * r;
        const metalLine = ctx.createLinearGradient(x1, y1, x2, y2);
        metalLine.addColorStop(0, "#6d461d");
        metalLine.addColorStop(0.4, "#e0b165");
        metalLine.addColorStop(1, "#8a5b25");
        ctx.strokeStyle = metalLine;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();

      // –±—Ä–æ–Ω–∑–æ–≤–∞—è –æ–∫–∞–Ω—Ç–æ–≤–∫–∞
      const rimGradient = ctx.createRadialGradient(cx, cy, r * 0.72, cx, cy, r + 10);
      rimGradient.addColorStop(0, "#6a3f17");
      rimGradient.addColorStop(0.38, "#b97a34");
      rimGradient.addColorStop(0.55, "#f0c97a");
      rimGradient.addColorStop(0.72, "#b97a34");
      rimGradient.addColorStop(1, "#4a2d12");
      ctx.beginPath();
      ctx.arc(cx, cy, r + 3, 0, Math.PI * 2);
      ctx.strokeStyle = rimGradient;
      ctx.lineWidth = 12;
      ctx.stroke();

      ctx.save();
      const rimHighlight = ctx.createLinearGradient(cx - r, cy - r, cx + r, cy + r);
      rimHighlight.addColorStop(0, "rgba(255,255,255,0)");
      rimHighlight.addColorStop(0.5, "rgba(255,236,196,0.35)");
      rimHighlight.addColorStop(1, "rgba(255,255,255,0)");
      ctx.strokeStyle = rimHighlight;
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(cx, cy, r + 3, -Math.PI * 0.2, Math.PI * 0.7);
      ctx.stroke();
      ctx.restore();

      // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∫–æ–ª—å—Ü–æ
      const innerGradient = ctx.createRadialGradient(cx, cy, innerRadius * 0.3, cx, cy, innerRadius);
      innerGradient.addColorStop(0, "#d4b07a");
      innerGradient.addColorStop(1, "#8b5a2c");
      ctx.beginPath();
      ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
      ctx.strokeStyle = innerGradient;
      ctx.lineWidth = 6;
      ctx.stroke();

      // —Ü–µ–Ω—Ç—Ä
      ctx.beginPath();
      ctx.arc(cx, cy, 24, 0, Math.PI * 2);
      ctx.fillStyle = "#f2e6cf";
      ctx.fill();
      ctx.strokeStyle = "#6b4a23";
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // ====== –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–µ–∫—Ç–æ—Ä–∞ (–∫—É–¥–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç—Ä–µ–ª–∫–∞ —Å–≤–µ—Ä—Ö—É) ======
    function pickIndex() {
      const n = items.length;
      const slice = (Math.PI * 2) / n;

      // –°—Ç—Ä–µ–ª–∫–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å–≤–µ—Ä—Ö—É (—É–≥–æ–ª -90¬∞), –Ω–æ –≤ canvas 0 —Ä–∞–¥ —Å–ø—Ä–∞–≤–∞.
      // –ü–æ—ç—Ç–æ–º—É —Å–¥–≤–∏–≥–∞–µ–º —Ç–∞–∫, —á—Ç–æ–±—ã "–≤–µ—Ä—Ö" –±—ã–ª —Ç–æ—á–∫–æ–π –≤—ã–±–æ—Ä–∞:
      const pointerAngle = -Math.PI / 2;

      // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —É–≥–æ–ª: –∫–∞–∫–æ–π —Å–µ–∫—Ç–æ—Ä —Å–µ–π—á–∞—Å –ø–æ–¥ —Å—Ç—Ä–µ–ª–∫–æ–π
      let a = (pointerAngle - angle) % (Math.PI * 2);
      if (a < 0) a += Math.PI * 2;

      const idx = Math.floor(a / slice);
      return idx;
    }

    // ====== –ü—Ä–æ—Å—Ç–µ–Ω—å–∫–∏–π RNG (–µ—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–≤—Ç–æ—Ä—è–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã) ======
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let x = Math.imul(t ^ (t >>> 15), 1 | t);
        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function parseItems(text) {
      const arr = text.split(",").map(s => s.trim()).filter(Boolean);
      return arr.length ? arr : ["–ü—Ä–∏–∑ 1", "–ü—Ä–∏–∑ 2", "–ü—Ä–∏–∑ 3"];
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    // ====== –ê–Ω–∏–º–∞—Ü–∏—è –≤—Ä–∞—â–µ–Ω–∏—è ======
    function spin() {
      if (spinning) return;

      items = parseItems(itemsInput.value);
      drawWheel();
      clearWinEffects();

      spinning = true;
      lastTickStep = null;


      if (tg) tg.MainButton.hide();

      spinBtn.disabled = true;
      setStatus("–ö—Ä—É—Ç–∏–º‚Ä¶");

      // RNG: –ª–∏–±–æ —Å–∏–¥, –ª–∏–±–æ –æ–±—ã—á–Ω—ã–π Math.random
      const seedVal = seedInput.value.trim();
      const rnd = seedVal ? mulberry32(Number(seedVal) || 123) : Math.random;

      // –•–æ—Ç–∏–º 4..7 –ø–æ–ª–Ω—ã—Ö –æ–±–æ—Ä–æ—Ç–æ–≤ + –¥–æ–∫—Ä—É—Ç–∫–∞
      const extraTurns = 4 + Math.floor((seedVal ? rnd() : Math.random()) * 4);
      const target = angle + extraTurns * Math.PI * 2 + (seedVal ? rnd() : Math.random()) * Math.PI * 2;

      const start = angle;
      const delta = target - start;

      const duration = 2600; // –º—Å
      const t0 = performance.now();

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function frame(now) {
        const t = Math.min(1, (now - t0) / duration);
        const eased = easeOutCubic(t);
        angle = start + delta * eased;
        const n = items.length;
const step = (Math.PI * 2) / (n * 2);
const tickStep = Math.floor(angle / step);

if (tickStep !== lastTickStep) {
  lastTickStep = tickStep;
  playTick();
  swordTick();
      }


        drawWheel();

        if (t < 1) {
          requestAnimationFrame(frame);
        } else {
          // –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
          angle = angle % (Math.PI * 2);
          const idx = pickIndex();
          const prize = items[idx];

          resultEl.textContent = "–†–µ–∑—É–ª—å—Ç–∞—Ç: " + prize;
          playWin();
          runWinEffects({ idx, prize, items });


if (tg) {
  tg.MainButton.setText("–ó–∞–±—Ä–∞—Ç—å –ø—Ä–∏–∑");
  tg.MainButton.show();

  // —á—Ç–æ–±—ã –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ –Ω–∞–∫–∞–ø–ª–∏–≤–∞–ª—Å—è –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –≤—Ä–∞—â–µ–Ω–∏—è—Ö
  tg.MainButton.offClick?.();

  tg.MainButton.onClick(() => {
    tg.sendData(JSON.stringify({ prize, idx, items }));
    // tg.close(); // –≤–∫–ª—é—á–∏—à—å –ø–æ–∑–∂–µ, –µ—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å –∑–∞–∫—Ä—ã–≤–∞—Ç—å –æ–∫–Ω–æ
  });
}

debugEl.textContent = `–°–µ–∫—Ç–æ—Ä #${idx + 1} –∏–∑ ${items.length}`;


          setStatus("–ì–æ—Ç–æ–≤–æ");
          spinning = false;
          spinBtn.disabled = false;
        }
      }

      requestAnimationFrame(frame);
    }

    // ====== –°–æ–±—ã—Ç–∏—è ======
    spinBtn.addEventListener("click", () => {
  ensureAudio();
  spin();
    });

    itemsInput.addEventListener("change", () => {
      items = parseItems(itemsInput.value);
      drawWheel();
    });

    // –ø–µ—Ä–≤—ã–π —Ä–µ–Ω–¥–µ—Ä
    drawWheel();
  </script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

</body>
</html>


